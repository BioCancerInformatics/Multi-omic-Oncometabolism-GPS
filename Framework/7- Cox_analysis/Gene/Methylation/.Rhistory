}
}
# Optional: Write the highest suffix found to a text file and print it
highest_suffix_found_path <- file.path(results_directory, "highest_suffix_found.txt")
write.table(highest_suffix_found,  # assuming 'highest_suffix_found' is your data
highest_suffix_found_path,
col.names = FALSE,
row.names = FALSE,
quote = FALSE)
# Optional: Print the highest suffix found
cat("The highest suffix found is: ", highest_suffix_found, "\n")
end_time <- now()
cat("Processing ended at:", format(end_time, "%Y-%m-%d %H:%M:%S"), "\n")
processing_time <- interval(start_time, end_time)
cat("Processing time:", as.duration(processing_time), "\n")
peak_memory <- round(max(memory.size()) / 1024, 2)
cat("Highest peak of RAM memory used:", peak_memory, "MB", "\n")
output_file <- "processing_stats.txt"
file_conn <- file(output_file, "a")
writeLines(paste("Start Time:", format(start_time, "%Y-%m-%d %H:%M:%S")), file_conn)
writeLines(paste("End Time:", format(end_time, "%Y-%m-%d %H:%M:%S")), file_conn)
writeLines(paste("Processing Time:", as.duration(processing_time)), file_conn)
writeLines(paste("Peak RAM Memory Used:", peak_memory, "MB"), file_conn)
# Close the file connection
close(file_conn)
# Save the current main_workspace to a file named 'main_workspace.RData' in the current working directory
save.image(file = "main_workspace.RData")
# Alternatively, if you want to confirm the file path where the main_workspace is saved, you can use:
current_working_directory <- getwd()  # Get the current working directory
main_workspace_path <- file.path(current_working_directory, "main_workspace.RData")  # Build the file path
save.image(file = main_workspace_path)  # Save the main_workspace
cat("main_workspace saved to: ", main_workspace_path, "\n")  # Print confirmation message with file path
# Save the session information to a file
main_session_info_path <- file.path(current_working_directory, "main_session_info.txt")
sink(main_session_info_path)  # Redirect output to file
sessionInfo()  # Print session information
sink()  # Stop redirecting output
cat("Session information saved to: ", main_session_info_path, "\n")
View(network_table)
# Diretório
setwd("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/Gene/Methylation/")
# Carregar os pacotes necessários
library(dplyr)
library(rio)
library(UCSCXenaShiny)
# Carregar os pacotes necessários
library(dplyr)
library(rio)
library(UCSCXenaShiny)
# Dataframe
genes <- import("/Higor/Cancer_metabolism_analysis_06/6- Merge all correlation results/Gene/All_results_gene.tsv")
genes <- genes[order(genes$genes), ]
# Filter the genes to include only rows where genotypic is "methylation"
genes <- genes %>% filter(Genotypic_var == "Methylation")
# Função para realizar análise de Cox para uma métrica específica
perform_cox_analysis <- function(genes, measure) {
results <- data.frame()  # Cria um data frame vazio para armazenar os resultados
# Usar unique para evitar repetições desnecessárias
unique_genes <- unique(genes$genes)
for (gene in unique_genes) {
cox_result <- vis_unicox_tree(
Gene = gene,
measure = measure,
data_type = "methylation",
threshold = 0.5
)
# Extrai os valores de p.value, Type e cancer
p_value <- cox_result[["data"]][["p.value"]]
Type <- cox_result[["data"]][["Type"]]
cancer <- cox_result[["data"]][["cancer"]]
# Cria um data frame temporário com os resultados atuais
temp_df <- data.frame(
Gene = gene,
p.value = p_value,
Type = Type,
cancer = cancer
)
# Adiciona o data frame temporário aos resultados principais
results <- rbind(results, temp_df)
}
# Renomeia as colunas em results para evitar conflitos ao mesclar
colnames(results) <- c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")
# Mescla os data frames genes e results pelo Gene e cancer_types
merged_genes <- merge(genes, results[, c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")],
by.x = c("genes", "cancer_types"),
by.y = c("Gene", "cancer"),
all.x = TRUE)
return(merged_genes)
}
# Aplicar a função para cada métrica e armazenar os resultados no data frame genes
measures <- c("OS", "DSS", "DFI", "PFI")
genes_merged <- genes
# Lista para armazenar os horários de conclusão
end_times <- list()
for (measure in measures) {
cat("Analisando métrica:", measure, "\n")  # Indicar a métrica atual
genes_merged <- perform_cox_analysis(genes_merged, measure)
end_times[[measure]] <- Sys.time()  # Armazenar o horário de conclusão
}
# Salva o resultado final em um arquivo tSV
export(genes_merged, "Cox_results.tsv")
# Imprime os horários de conclusão
print(end_times)
View(genes_merged)
#### RSCRIPT COX ANALYSIS
#### HIGOR ALMEIDA, EMANNUEL, ENRIQUE MEDINA-ACOSTA
#### LAST VERSION - 12/08/2024
# Diretório
setwd("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/Gene/Methylation/")
# Carregar os pacotes necessários
library(dplyr)
library(rio)
library(UCSCXenaShiny)
# Dataframe
genes <- import("/Higor/Cancer_metabolism_analysis_06/6- Merge all correlation results/Gene/All_results_gene.tsv")
genes <- genes[order(genes$genes), ]
# Filter the genes to include only rows where genotypic is "Mutation"
genes <- genes %>% filter(Genotypic_var == "Mutation")
# Função para realizar análise de Cox para uma métrica específica
perform_cox_analysis <- function(genes, measure) {
results <- data.frame()  # Cria um data frame vazio para armazenar os resultados
# Usar unique para evitar repetições desnecessárias
unique_genes <- unique(genes$genes)
for (gene in unique_genes) {
cox_result <- vis_unicox_tree(
Gene = gene,
measure = measure,
data_type = "mutation",
threshold = 0.5
)
# Extrai os valores de p.value, Type e cancer
p_value <- cox_result[["data"]][["p.value"]]
Type <- cox_result[["data"]][["Type"]]
cancer <- cox_result[["data"]][["cancer"]]
# Cria um data frame temporário com os resultados atuais
temp_df <- data.frame(
Gene = gene,
p.value = p_value,
Type = Type,
cancer = cancer
)
# Adiciona o data frame temporário aos resultados principais
results <- rbind(results, temp_df)
}
# Renomeia as colunas em results para evitar conflitos ao mesclar
colnames(results) <- c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")
# Mescla os data frames genes e results pelo Gene e cancer_types
merged_genes <- merge(genes, results[, c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")],
by.x = c("genes", "cancer_types"),
by.y = c("Gene", "cancer"),
all.x = TRUE)
return(merged_genes)
}
# Aplicar a função para cada métrica e armazenar os resultados no data frame genes
measures <- c("OS", "DSS", "DFI", "PFI")
genes_merged <- genes
# Lista para armazenar os horários de conclusão
end_times <- list()
for (measure in measures) {
cat("Analisando métrica:", measure, "\n")  # Indicar a métrica atual
genes_merged <- perform_cox_analysis(genes_merged, measure)
end_times[[measure]] <- Sys.time()  # Armazenar o horário de conclusão
}
# Salva o resultado final em um arquivo tSV
export(genes_merged, "Cox_results.tsv")
# Imprime os horários de conclusão
print(end_times)
View(genes_merged)
# Diretório
setwd("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/lncRNA/Expression/")
# Carregar os pacotes necessários
library(dplyr)
library(rio)
library(UCSCXenaShiny)
# Dataframe
genes <- import("/Higor/Cancer_metabolism_analysis_06/6- Merge all correlation results/lncRNA/All_results_lncRNA.tsv")
genes <- genes[order(genes$genes), ]
# Filter the genes to include only rows where genotypic is "methylation"
genes <- genes %>% filter(Genotypic_var == "Gene expression")
# Função para realizar análise de Cox para uma métrica específica
perform_cox_analysis <- function(genes, measure) {
results <- data.frame()  # Cria um data frame vazio para armazenar os resultados
# Usar unique para evitar repetições desnecessárias
unique_genes <- unique(genes$genes)
for (gene in unique_genes) {
cox_result <- vis_unicox_tree(
Gene = gene,
measure = measure,
data_type = "mRNA",
threshold = 0.5
)
# Extrai os valores de p.value, Type e cancer
p_value <- cox_result[["data"]][["p.value"]]
Type <- cox_result[["data"]][["Type"]]
cancer <- cox_result[["data"]][["cancer"]]
# Cria um data frame temporário com os resultados atuais
temp_df <- data.frame(
Gene = gene,
p.value = p_value,
Type = Type,
cancer = cancer
)
# Adiciona o data frame temporário aos resultados principais
results <- rbind(results, temp_df)
}
# Renomeia as colunas em results para evitar conflitos ao mesclar
colnames(results) <- c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")
# Mescla os data frames genes e results pelo Gene e cancer_types
merged_genes <- merge(genes, results[, c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")],
by.x = c("genes", "cancer_types"),
by.y = c("Gene", "cancer"),
all.x = TRUE)
return(merged_genes)
}
# Aplicar a função para cada métrica e armazenar os resultados no data frame genes
measures <- c("OS", "DSS", "DFI", "PFI")
genes_merged <- genes
# Lista para armazenar os horários de conclusão
end_times <- list()
for (measure in measures) {
cat("Analisando métrica:", measure, "\n")  # Indicar a métrica atual
genes_merged <- perform_cox_analysis(genes_merged, measure)
end_times[[measure]] <- Sys.time()  # Armazenar o horário de conclusão
}
# Salva o resultado final em um arquivo tSV
export(genes_merged, "Cox_results.tsv")
# Imprime os horários de conclusão
print(end_times)
# Diretório
setwd("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/Protein/")
# Carregar os pacotes necessários
library(dplyr)
library(rio)
library(UCSCXenaShiny)
# Dataframe
genes <- import("/Higor/Cancer_metabolism_analysis_06/6- Merge all correlation results/Gene/All_results_gene.tsv")
genes <- genes[order(genes$genes), ]
# Diretório
setwd("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/Protein/")
# Carregar os pacotes necessários
library(dplyr)
library(rio)
library(UCSCXenaShiny)
# Dataframe
genes <- import("/Higor/Cancer_metabolism_analysis_06/6- Merge all correlation results/Gene/All_results_gene.tsv")
genes <- genes[order(genes$genes), ]
# Filter the genes to include only rows where genotypic is "Protein"
genes <- genes %>% filter(Genotypic_var == "Protein expression")
# Função para realizar análise de Cox para uma métrica específica
perform_cox_analysis <- function(genes, measure) {
results <- data.frame()  # Cria um data frame vazio para armazenar os resultados
# Usar unique para evitar repetições desnecessárias
unique_genes <- unique(genes$genes)
for (gene in unique_genes) {
cox_result <- vis_unicox_tree(
Gene = gene,
measure = measure,
data_type = "protein",
threshold = 0.5
)
# Extrai os valores de p.value, Type e cancer
p_value <- cox_result[["data"]][["p.value"]]
Type <- cox_result[["data"]][["Type"]]
cancer <- cox_result[["data"]][["cancer"]]
# Cria um data frame temporário com os resultados atuais
temp_df <- data.frame(
Gene = gene,
p.value = p_value,
Type = Type,
cancer = cancer
)
# Adiciona o data frame temporário aos resultados principais
results <- rbind(results, temp_df)
}
# Renomeia as colunas em results para evitar conflitos ao mesclar
colnames(results) <- c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")
# Mescla os data frames genes e results pelo Gene e cancer_types
merged_genes <- merge(genes, results[, c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")],
by.x = c("genes", "cancer_types"),
by.y = c("Gene", "cancer"),
all.x = TRUE)
return(merged_genes)
}
# Aplicar a função para cada métrica e armazenar os resultados no data frame genes
measures <- c("OS", "DSS", "DFI", "PFI")
genes_merged <- genes
# Lista para armazenar os horários de conclusão
end_times <- list()
for (measure in measures) {
cat("Analisando métrica:", measure, "\n")  # Indicar a métrica atual
genes_merged <- perform_cox_analysis(genes_merged, measure)
end_times[[measure]] <- Sys.time()  # Armazenar o horário de conclusão
}
# Salva o resultado final em um arquivo tSV
export(genes_merged, "Cox_results.tsv")
# Imprime os horários de conclusão
print(end_times)
View(genes_merged)
# Diretório
setwd("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/Transcript/Coding gene/")
# Carregar os pacotes necessários
library(dplyr)
library(rio)
library(UCSCXenaShiny)
# Dataframe
genes <- import("/Higor/Cancer_metabolism_analysis_06/6- Merge all correlation results/Transcript/Coding gene/All_results_transcript.tsv")
genes <- genes[order(genes$genes), ]
# Função para realizar análise de Cox para uma métrica específica
perform_cox_analysis <- function(genes, measure) {
results <- data.frame()  # Cria um data frame vazio para armazenar os resultados
# Usar unique para evitar repetições desnecessárias
unique_genes <- unique(genes$genes)
for (gene in unique_genes) {
cox_result <- vis_unicox_tree(
Gene = gene,
measure = measure,
data_type = "transcript",
threshold = 0.5
)
# Extrai os valores de p.value, Type e cancer
p_value <- cox_result[["data"]][["p.value"]]
Type <- cox_result[["data"]][["Type"]]
cancer <- cox_result[["data"]][["cancer"]]
# Cria um data frame temporário com os resultados atuais
temp_df <- data.frame(
Gene = gene,
p.value = p_value,
Type = Type,
cancer = cancer
)
# Adiciona o data frame temporário aos resultados principais
results <- rbind(results, temp_df)
}
# Renomeia as colunas em results para evitar conflitos ao mesclar
colnames(results) <- c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")
# Mescla os data frames genes e results pelo Gene e cancer_types
merged_genes <- merge(genes, results[, c("Gene", paste0("p.value_Cox_", measure), paste0("Type_Cox_", measure), "cancer")],
by.x = c("genes", "cancer_types"),
by.y = c("Gene", "cancer"),
all.x = TRUE)
return(merged_genes)
}
# Aplicar a função para cada métrica e armazenar os resultados no data frame genes
measures <- c("OS", "DSS", "DFI", "PFI")
genes_merged <- genes
# Lista para armazenar os horários de conclusão
end_times <- list()
for (measure in measures) {
cat("Analisando métrica:", measure, "\n")  # Indicar a métrica atual
genes_merged <- perform_cox_analysis(genes_merged, measure)
end_times[[measure]] <- Sys.time()  # Armazenar o horário de conclusão
}
# Salva o resultado final em um arquivo tSV
export(genes_merged, "Cox_results.tsv")
# Imprime os horários de conclusão
print(end_times)
# Load required libraries
library("rio")
library("UCSCXenaShiny")
library("dplyr")
library("survival")
# Set directory
setwd("F:/Higor/Cancer_metabolism_analysis_06/8- Survival_Analysis/Gene/Methylation/")
# Import table
table <- import("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/Gene/Methylation/Cox_results.tsv")
# Initialize new columns for each survival metric
survival_metrics <- c("OS", "DSS", "DFI", "PFI")
for (metric in survival_metrics) {
table[[paste0(metric, "_log_rank_chisq")]] <- NA
table[[paste0(metric, "_p_val")]] <- NA
table[[paste0(metric, "_worst_prognosis_group")]] <- NA
}
# Function to perform survival analysis for a given metric
perform_survival_analysis <- function(genes, cancer_type, metric) {
cat("Running survival analysis for gene:", genes, "and cancer_type:", cancer_type, "on metric:", metric, "\n")
# Load survival data with error handling
data_surv <- tryCatch({
tcga_surv_get(
genes,
TCGA_cohort = cancer_type,
profile = "methylation",
TCGA_cli_data = dplyr::inner_join(
load_data("tcga_clinical"),
load_data("tcga_surv"),
by = "sample"
))
}, error = function(e) {
warning(paste("Failed to load survival data for gene:", genes, "and cancer_type:", cancer_type, ":", e$message))
return(NULL)
})
if (is.null(data_surv)) {
warning(paste("No survival data for gene:", genes, "and cancer_type:", cancer_type))
return(NULL)
}
# Create survival plot
plot_surv <- tryCatch({
tcga_surv_plot(
data_surv,
time = paste0(metric, ".time"),  # Use the appropriate survival time metric
status = metric,  # Use the appropriate survival status metric
cutoff_mode = "Custom",
cutpoint = c(50, 50),
profile = "mRNA",
palette = "aaas"
)
}, error = function(e) {
warning(paste("Failed to create survival plot for", genes, "in", cancer_type, ":", e$message))
return(NULL)
})
# Process data for survival analysis
data_surv <- data_surv %>%
arrange(.data$value) %>%
mutate(per_rank = percent_rank(.data$value) * 100) %>%
mutate(group = case_when(
.data$per_rank > 50 ~ "High",
.data$per_rank <= 50 ~ "Low",
TRUE ~ NA_character_
)) %>%
filter(!is.na(group))
# Calculate log-rank test
surv_diff <- tryCatch({
survdiff(Surv(data_surv[[paste0(metric, ".time")]], data_surv[[metric]]) ~ group, data = data_surv)
}, error = function(e) {
warning(paste("Failed to calculate survival differences for", metric, ":", e$message))
return(NULL)
})
if (is.null(surv_diff)) return(NULL)
# Extract p-value and chi-squared statistic
p_val <- 1 - pchisq(surv_diff$chisq, length(surv_diff$n) - 1)
chisq_log_rank <- surv_diff$chisq
# Determine worst prognosis group considering multiple survival points
group_surv_multiple <- tryCatch({
plot_surv[["plot"]][["data"]] %>%
group_by(group) %>%
summarize(
time_40 = min(time[surv <= 0.4], na.rm = TRUE),
time_50 = min(time[surv <= 0.5], na.rm = TRUE),
time_60 = min(time[surv <= 0.6], na.rm = TRUE),
time_70 = min(time[surv <= 0.7], na.rm = TRUE),
time_80 = min(time[surv <= 0.8], na.rm = TRUE),  # 0.8 survival point
time_90 = min(time[surv <= 0.9], na.rm = TRUE)   # Added 0.9 survival point
)
}, error = function(e) {
warning(paste("Failed to summarize survival data for", metric, ":", e$message))
return(NULL)
})
worst_prognosis_group <- if (!is.null(group_surv_multiple)) {
if (p_val >= 0.05) {
"NS"  # Not significant
} else {
# Count how many times "Low" reaches the minimum time at each survival point
low_wins <- sum(
!is.na(group_surv_multiple$time_40) && group_surv_multiple$time_40[group_surv_multiple$group == "Low"] < group_surv_multiple$time_40[group_surv_multiple$group == "High"],
!is.na(group_surv_multiple$time_50) && group_surv_multiple$time_50[group_surv_multiple$group == "Low"] < group_surv_multiple$time_50[group_surv_multiple$group == "High"],
!is.na(group_surv_multiple$time_60) && group_surv_multiple$time_60[group_surv_multiple$group == "Low"] < group_surv_multiple$time_60[group_surv_multiple$group == "High"],
!is.na(group_surv_multiple$time_70) && group_surv_multiple$time_70[group_surv_multiple$group == "Low"] < group_surv_multiple$time_70[group_surv_multiple$group == "High"],
!is.na(group_surv_multiple$time_80) && group_surv_multiple$time_80[group_surv_multiple$group == "Low"] < group_surv_multiple$time_80[group_surv_multiple$group == "High"],
!is.na(group_surv_multiple$time_90) && group_surv_multiple$time_90[group_surv_multiple$group == "Low"] < group_surv_multiple$time_90[group_surv_multiple$group == "High"]  # Added 0.9 comparison
)
high_wins <- sum(
!is.na(group_surv_multiple$time_40) && group_surv_multiple$time_40[group_surv_multiple$group == "High"] < group_surv_multiple$time_40[group_surv_multiple$group == "Low"],
!is.na(group_surv_multiple$time_50) && group_surv_multiple$time_50[group_surv_multiple$group == "High"] < group_surv_multiple$time_50[group_surv_multiple$group == "Low"],
!is.na(group_surv_multiple$time_60) && group_surv_multiple$time_60[group_surv_multiple$group == "High"] < group_surv_multiple$time_60[group_surv_multiple$group == "Low"],
!is.na(group_surv_multiple$time_70) && group_surv_multiple$time_70[group_surv_multiple$group == "High"] < group_surv_multiple$time_70[group_surv_multiple$group == "Low"],
!is.na(group_surv_multiple$time_80) && group_surv_multiple$time_80[group_surv_multiple$group == "High"] < group_surv_multiple$time_80[group_surv_multiple$group == "Low"],
!is.na(group_surv_multiple$time_90) && group_surv_multiple$time_90[group_surv_multiple$group == "High"] < group_surv_multiple$time_90[group_surv_multiple$group == "Low"]  # Added 0.9 comparison
)
if (low_wins > high_wins) {
"Low"
} else if (high_wins > low_wins) {
"High"
} else {
# Tie-breaking criterion at 0.5
ifelse(group_surv_multiple$time_50[group_surv_multiple$group == "Low"] < group_surv_multiple$time_50[group_surv_multiple$group == "High"],
"Low", "High")
}
}
} else {
NA
}
return(list(chisq = chisq_log_rank, p_val = p_val, worst_prognosis_group = worst_prognosis_group))
}
# Loop to analyze each gene and cancer_type for all survival metrics
for (i in 1:nrow(table)) {
cancer_type <- table$cancer_type[i]
genes <- table$genes[i]
cat("Processing gene:", genes, "for cancer_type:", cancer_type, "\n")
for (metric in survival_metrics) {
cat("Analyzing metric:", metric, "for gene:", genes, "and cancer_type:", cancer_type, "\n")
result <- perform_survival_analysis(genes, cancer_type, metric)
if (!is.null(result)) {
table[[paste0(metric, "_log_rank_chisq")]][i] <- result$chisq
table[[paste0(metric, "_p_val")]][i] <- result$p_val
table[[paste0(metric, "_worst_prognosis_group")]][i] <- result$worst_prognosis_group
}
cat("Completed metric:", metric, "for gene:", genes, "and cancer_type:", cancer_type, "\n")
}
cat("Finished processing gene:", genes, "for cancer_type:", cancer_type, "\n")
}
# Load required libraries
library("rio")
library("UCSCXenaShiny")
library("dplyr")
library("survival")
# Set directory
setwd("F:/Higor/Cancer_metabolism_analysis_06/8- Survival_Analysis/Gene/Mutation/")
# Import table
table <- import("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/Gene/Mutation/Cox_Analysis.R")
# Set directory
setwd("F:/Higor/Cancer_metabolism_analysis_06/8- Survival_Analysis/Gene/Mutation/")
# Import table
table <- import("F:/Higor/Cancer_metabolism_analysis_06/7- Cox_Analysis/Gene/Mutation/Cox_Analysis.R")
